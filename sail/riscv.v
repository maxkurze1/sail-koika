(*Generated by Sail from riscv.*)
Require Import Sail.Base.
Require Import Sail.Real.
Require Import riscv_types.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition eq_unit (_ : unit) (_ : unit) : bool := true.

Definition neq_int (x : Z) (y : Z) : bool := negb (Z.eqb x y).

Definition neq_bool (x : bool) (y : bool) : bool := negb (Bool.eqb x y).

Definition __id (x : Z) : Z := x.



Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb len (length_mword v) then vector_truncate v len else zero_extend v len.

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb l n then shiftl (sail_ones n) i
   else
     let one : bits n := sail_mask n (('b"1")  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shl_int m n else shr_int m (Z.opp n).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shr_int m n else shl_int m (Z.opp n).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb (Z.ltb n 0) (Z.gtb m 0) then Z.sub (Z.quot (Z.add n 1) m) 1
   else if andb (Z.gtb n 0) (Z.ltb m 0) then Z.sub (Z.quot (Z.sub n 1) m) 1
   else Z.quot n m.

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub n (Z.mul m (fdiv_int n m)).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append str (string_of_bits x).

Definition concat_str_dec (str : string) (x : Z) : string := String.append str (dec_str x).

Definition sign_extend' {n : Z} (m : Z) (v : mword n) (*m >=? n*) : mword m := sign_extend v m.

Definition zero_extend' {n : Z} (m : Z) (v : mword n) (*m >=? n*) : mword m := zero_extend v m.

Definition zero_reg : regtype := zero_extend' 32 ((Ox"0")  : mword 4).
#[export] Hint Unfold zero_reg : sail.
Definition regval_from_reg (r : mword 32) : mword 32 := r.

Definition regval_into_reg (v : mword 32) : mword 32 := v.

Definition rX (r : Z) (*(0 <=? r) && (r <=? 31)*) : M (mword 32) :=
   let l__42 := r in
   (if Z.eqb l__42 0 then returnM zero_reg
    else if Z.eqb l__42 1 return M (mword 32) then
      ((read_reg x1_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 2 return M (mword 32) then
      ((read_reg x2_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 3 return M (mword 32) then
      ((read_reg x3_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 4 return M (mword 32) then
      ((read_reg x4_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 5 return M (mword 32) then
      ((read_reg x5_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 6 return M (mword 32) then
      ((read_reg x6_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 7 return M (mword 32) then
      ((read_reg x7_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 8 return M (mword 32) then
      ((read_reg x8_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 9 return M (mword 32) then
      ((read_reg x9_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 10 return M (mword 32) then
      ((read_reg x10_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 11 return M (mword 32) then
      ((read_reg x11_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 12 return M (mword 32) then
      ((read_reg x12_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 13 return M (mword 32) then
      ((read_reg x13_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 14 return M (mword 32) then
      ((read_reg x14_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 15 return M (mword 32) then
      ((read_reg x15_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 16 return M (mword 32) then
      ((read_reg x16_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 17 return M (mword 32) then
      ((read_reg x17_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 18 return M (mword 32) then
      ((read_reg x18_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 19 return M (mword 32) then
      ((read_reg x19_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 20 return M (mword 32) then
      ((read_reg x20_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 21 return M (mword 32) then
      ((read_reg x21_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 22 return M (mword 32) then
      ((read_reg x22_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 23 return M (mword 32) then
      ((read_reg x23_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 24 return M (mword 32) then
      ((read_reg x24_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 25 return M (mword 32) then
      ((read_reg x25_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 26 return M (mword 32) then
      ((read_reg x26_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 27 return M (mword 32) then
      ((read_reg x27_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 28 return M (mword 32) then
      ((read_reg x28_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 29 return M (mword 32) then
      ((read_reg x29_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 30 return M (mword 32) then
      ((read_reg x30_ref)  : M (mword 32))
       : M (mword 32)
    else if Z.eqb l__42 31 return M (mword 32) then
      ((read_reg x31_ref)  : M (mword 32))
       : M (mword 32)
    else assert_exp' false "invalid register number" >>= fun _ => exit tt) >>= fun (v : regtype) =>
   returnM (regval_from_reg v).

Definition wX (r : Z) (in_v : mword 32) (*(0 <=? r) && (r <=? 31)*) : M (unit) :=
   let v := regval_into_reg in_v in
   let l__10 := r in
   (if Z.eqb l__10 0 then returnM tt
    else if Z.eqb l__10 1 return M (unit) then write_reg x1_ref v  : M (unit)
    else if Z.eqb l__10 2 return M (unit) then write_reg x2_ref v  : M (unit)
    else if Z.eqb l__10 3 return M (unit) then write_reg x3_ref v  : M (unit)
    else if Z.eqb l__10 4 return M (unit) then write_reg x4_ref v  : M (unit)
    else if Z.eqb l__10 5 return M (unit) then write_reg x5_ref v  : M (unit)
    else if Z.eqb l__10 6 return M (unit) then write_reg x6_ref v  : M (unit)
    else if Z.eqb l__10 7 return M (unit) then write_reg x7_ref v  : M (unit)
    else if Z.eqb l__10 8 return M (unit) then write_reg x8_ref v  : M (unit)
    else if Z.eqb l__10 9 return M (unit) then write_reg x9_ref v  : M (unit)
    else if Z.eqb l__10 10 return M (unit) then write_reg x10_ref v  : M (unit)
    else if Z.eqb l__10 11 return M (unit) then write_reg x11_ref v  : M (unit)
    else if Z.eqb l__10 12 return M (unit) then write_reg x12_ref v  : M (unit)
    else if Z.eqb l__10 13 return M (unit) then write_reg x13_ref v  : M (unit)
    else if Z.eqb l__10 14 return M (unit) then write_reg x14_ref v  : M (unit)
    else if Z.eqb l__10 15 return M (unit) then write_reg x15_ref v  : M (unit)
    else if Z.eqb l__10 16 return M (unit) then write_reg x16_ref v  : M (unit)
    else if Z.eqb l__10 17 return M (unit) then write_reg x17_ref v  : M (unit)
    else if Z.eqb l__10 18 return M (unit) then write_reg x18_ref v  : M (unit)
    else if Z.eqb l__10 19 return M (unit) then write_reg x19_ref v  : M (unit)
    else if Z.eqb l__10 20 return M (unit) then write_reg x20_ref v  : M (unit)
    else if Z.eqb l__10 21 return M (unit) then write_reg x21_ref v  : M (unit)
    else if Z.eqb l__10 22 return M (unit) then write_reg x22_ref v  : M (unit)
    else if Z.eqb l__10 23 return M (unit) then write_reg x23_ref v  : M (unit)
    else if Z.eqb l__10 24 return M (unit) then write_reg x24_ref v  : M (unit)
    else if Z.eqb l__10 25 return M (unit) then write_reg x25_ref v  : M (unit)
    else if Z.eqb l__10 26 return M (unit) then write_reg x26_ref v  : M (unit)
    else if Z.eqb l__10 27 return M (unit) then write_reg x27_ref v  : M (unit)
    else if Z.eqb l__10 28 return M (unit) then write_reg x28_ref v  : M (unit)
    else if Z.eqb l__10 29 return M (unit) then write_reg x29_ref v  : M (unit)
    else if Z.eqb l__10 30 return M (unit) then write_reg x30_ref v  : M (unit)
    else if Z.eqb l__10 31 return M (unit) then write_reg x31_ref v  : M (unit)
    else assert_exp' false "invalid register number" >>= fun _ => exit tt)
    : M (unit).

Definition rX_bits (i : mword 5) : M (mword 32) := (rX (uint i))  : M (mword 32).

Definition wX_bits (i : mword 5) (data : mword 32) : M (unit) := (wX (uint i) data)  : M (unit).

Definition Retired_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : Retired :=
   let l__9 := arg_ in
   if Z.eqb l__9 0 then RETIRE_SUCCESS
   else RETIRE_FAIL.

Definition num_of_Retired (arg_ : Retired) : Z :=
   match arg_ with | RETIRE_SUCCESS => 0 | RETIRE_FAIL => 1 end.

Definition rop_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 9)*) : rop :=
   let l__0 := arg_ in
   if Z.eqb l__0 0 then RISCV_ADD
   else if Z.eqb l__0 1 then RISCV_SUB
   else if Z.eqb l__0 2 then RISCV_SLL
   else if Z.eqb l__0 3 then RISCV_SLT
   else if Z.eqb l__0 4 then RISCV_SLTU
   else if Z.eqb l__0 5 then RISCV_XOR
   else if Z.eqb l__0 6 then RISCV_SRL
   else if Z.eqb l__0 7 then RISCV_SRA
   else if Z.eqb l__0 8 then RISCV_OR
   else RISCV_AND.

Definition num_of_rop (arg_ : rop) : Z :=
   match arg_ with
   | RISCV_ADD => 0
   | RISCV_SUB => 1
   | RISCV_SLL => 2
   | RISCV_SLT => 3
   | RISCV_SLTU => 4
   | RISCV_XOR => 5
   | RISCV_SRL => 6
   | RISCV_SRA => 7
   | RISCV_OR => 8
   | RISCV_AND => 9
   end.

Definition funct3_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 0)*) : funct3 :=
   match arg_ with | _ => funct3_ADD end.

Definition num_of_funct3 (arg_ : funct3) : Z := match arg_ with | funct3_ADD => 0 end.

Definition funct7_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 0)*) : funct7 :=
   match arg_ with | _ => funct7_ADD end.

Definition num_of_funct7 (arg_ : funct7) : Z := match arg_ with | funct7_ADD => 0 end.

Definition funct3_bits_forwards (arg_ : funct3) : M (mword 3) :=
   returnM (match arg_ with | funct3_ADD => ('b"000")  : mword 3 end).

Definition funct3_bits_backwards (arg_ : mword 3) : M (funct3) :=
   let b__0 := arg_ in
   (if eq_vec b__0 (('b"000")  : mword 3) then returnM funct3_ADD
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (funct3).

Definition funct3_bits_forwards_matches (arg_ : funct3) : M (bool) :=
   returnM (match arg_ with | funct3_ADD => true end).

Definition funct3_bits_backwards_matches (arg_ : mword 3) : M (bool) :=
   returnM
   (let b__0 := arg_ in
   if eq_vec b__0 (('b"000")  : mword 3) then true
   else false).

Definition alu32 (funct3 : funct3) (funct7 : funct7) (a : mword 32) (b : mword 32) : mword 32 :=
   match funct3 with | funct3_ADD => add_vec a b end.

Definition initial_regstate : regstate :=
{| x31 := (Ox"00000000")  : mword 32;
   x30 := (Ox"00000000")  : mword 32;
   x29 := (Ox"00000000")  : mword 32;
   x28 := (Ox"00000000")  : mword 32;
   x27 := (Ox"00000000")  : mword 32;
   x26 := (Ox"00000000")  : mword 32;
   x25 := (Ox"00000000")  : mword 32;
   x24 := (Ox"00000000")  : mword 32;
   x23 := (Ox"00000000")  : mword 32;
   x22 := (Ox"00000000")  : mword 32;
   x21 := (Ox"00000000")  : mword 32;
   x20 := (Ox"00000000")  : mword 32;
   x19 := (Ox"00000000")  : mword 32;
   x18 := (Ox"00000000")  : mword 32;
   x17 := (Ox"00000000")  : mword 32;
   x16 := (Ox"00000000")  : mword 32;
   x15 := (Ox"00000000")  : mword 32;
   x14 := (Ox"00000000")  : mword 32;
   x13 := (Ox"00000000")  : mword 32;
   x12 := (Ox"00000000")  : mword 32;
   x11 := (Ox"00000000")  : mword 32;
   x10 := (Ox"00000000")  : mword 32;
   x9 := (Ox"00000000")  : mword 32;
   x8 := (Ox"00000000")  : mword 32;
   x7 := (Ox"00000000")  : mword 32;
   x6 := (Ox"00000000")  : mword 32;
   x5 := (Ox"00000000")  : mword 32;
   x4 := (Ox"00000000")  : mword 32;
   x3 := (Ox"00000000")  : mword 32;
   x2 := (Ox"00000000")  : mword 32;
   x1 := (Ox"00000000")  : mword 32 |}.
#[export] Hint Unfold initial_regstate : sail.


