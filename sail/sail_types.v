(*Generated by Sail from sail.*)
Require Import Sail.Base.
Require Import Sail.Real.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Inductive register_value :=
| Regval_vector : list register_value -> register_value
| Regval_list : list register_value -> register_value
| Regval_option : option register_value -> register_value
| Regval_bool : bool -> register_value
| Regval_int : Z -> register_value
| Regval_real : R -> register_value
| Regval_string : string -> register_value
| Regval_bit : bitU -> register_value
| Regval_bitvector_16 : mword 16 -> register_value
| Regval_bitvector_32 : mword 32 -> register_value.
Arguments register_value : clear implicits.

#[export]
Instance dummy_register_value : Inhabited (register_value) := {
  inhabitant := Regval_vector inhabitant
}.

Record regstate := {
  ANOTHER_REG : mword 16;
  SOME_REG : mword 32;
}.
Arguments regstate : clear implicits.
Notation "{[ r 'with' 'ANOTHER_REG' := e ]}" :=
  match r with Build_regstate _ f1 => Build_regstate e f1 end.
Notation "{[ r 'with' 'SOME_REG' := e ]}" :=
  match r with Build_regstate f0 _ => Build_regstate f0 e end.
#[export]
Instance dummy_regstate : Inhabited (regstate ) := {
  inhabitant := {| ANOTHER_REG := inhabitant; SOME_REG := inhabitant
|} }.




Definition bit_of_regval (merge_var : register_value) : option bitU :=
   match merge_var with | Regval_bit v => Some v | _ => None end.

Definition regval_of_bit (v : bitU) : register_value := Regval_bit v.

Definition bitvector_16_of_regval (merge_var : register_value) : option (mword 16) :=
   match merge_var with | Regval_bitvector_16 v => Some v | _ => None end.

Definition regval_of_bitvector_16 (v : mword 16) : register_value := Regval_bitvector_16 v.

Definition bitvector_32_of_regval (merge_var : register_value) : option (mword 32) :=
   match merge_var with | Regval_bitvector_32 v => Some v | _ => None end.

Definition regval_of_bitvector_32 (v : mword 32) : register_value := Regval_bitvector_32 v.



Definition bool_of_regval (merge_var : register_value) : option bool :=
  match merge_var with | Regval_bool v => Some v | _ => None end.

Definition regval_of_bool (v : bool) : register_value := Regval_bool v.

Definition int_of_regval (merge_var : register_value) : option Z :=
  match merge_var with | Regval_int v => Some v | _ => None end.

Definition regval_of_int (v : Z) : register_value := Regval_int v.

Definition real_of_regval (merge_var : register_value) : option R :=
  match merge_var with | Regval_real v => Some v | _ => None end.

Definition regval_of_real (v : R) : register_value := Regval_real v.

Definition string_of_regval (merge_var : register_value) : option string :=
  match merge_var with | Regval_string v => Some v | _ => None end.

Definition regval_of_string (v : string) : register_value := Regval_string v.

Definition vector_of_regval {a} n (of_regval : register_value -> option a) (rv : register_value) : option (vec a n) := match rv with
  | Regval_vector v => if n =? length_list v then map_bind (vec_of_list n) (just_list (List.map of_regval v)) else None
  | _ => None
end.

Definition regval_of_vector {a size} (regval_of : a -> register_value) (xs : vec a size) : register_value := Regval_vector (List.map regval_of (list_of_vec xs)).

Definition list_of_regval {a} (of_regval : register_value -> option a) (rv : register_value) : option (list a) := match rv with
  | Regval_list v => just_list (List.map of_regval v)
  | _ => None
end.

Definition regval_of_list {a} (regval_of : a -> register_value) (xs : list a) : register_value := Regval_list (List.map regval_of xs).

Definition option_of_regval {a} (of_regval : register_value -> option a) (rv : register_value) : option (option a) := match rv with
  | Regval_option v => option_map of_regval v
  | _ => None
end.

Definition regval_of_option {a} (regval_of : a -> register_value) (v : option a) := Regval_option (option_map regval_of v).


Definition ANOTHER_REG_ref := {|
  name := "ANOTHER_REG";
  read_from := (fun s => s.(ANOTHER_REG));
  write_to := (fun v s => ({[ s with ANOTHER_REG := v ]}));
  of_regval := (fun v => bitvector_16_of_regval v);
  regval_of := (fun v => regval_of_bitvector_16 v) |}.

Definition SOME_REG_ref := {|
  name := "SOME_REG";
  read_from := (fun s => s.(SOME_REG));
  write_to := (fun v s => ({[ s with SOME_REG := v ]}));
  of_regval := (fun v => bitvector_32_of_regval v);
  regval_of := (fun v => regval_of_bitvector_32 v) |}.

Local Open Scope string.
Definition get_regval (reg_name : string) (s : regstate) : option register_value :=
  if string_dec reg_name "ANOTHER_REG" then Some (ANOTHER_REG_ref.(regval_of) (ANOTHER_REG_ref.(read_from) s)) else
  if string_dec reg_name "SOME_REG" then Some (SOME_REG_ref.(regval_of) (SOME_REG_ref.(read_from) s)) else
  None.

Definition set_regval (reg_name : string) (v : register_value) (s : regstate) : option regstate :=
  if string_dec reg_name "ANOTHER_REG" then option_map (fun v => ANOTHER_REG_ref.(write_to) v s) (ANOTHER_REG_ref.(of_regval) v) else
  if string_dec reg_name "SOME_REG" then option_map (fun v => SOME_REG_ref.(write_to) v s) (SOME_REG_ref.(of_regval) v) else
  None.

Definition register_accessors := (get_regval, set_regval).


Definition MR a r := monadR register_value a r unit.
Definition M a := monad register_value a unit.
Definition returnM {A:Type} := @returnm register_value A unit.
Definition returnR {A:Type} (R:Type) := @returnm register_value A (R + unit).