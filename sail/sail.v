(*Generated by Sail from sail.*)
Require Import Sail.Base.
Require Import Sail.Real.
Require Import sail_types.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition eq_unit (_ : unit) (_ : unit) : bool := true.

Definition neq_int (x : Z) (y : Z) : bool := negb (Z.eqb x y).

Definition neq_bool (x : bool) (y : bool) : bool := negb (Bool.eqb x y).

Definition __id (x : Z) : Z := x.



Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb len (length_mword v) then vector_truncate v len else zero_extend v len.

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb l n then shiftl (sail_ones n) i
   else
     let one : bits n := sail_mask n (('b"1")  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shl_int m n else shr_int m (Z.opp n).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shr_int m n else shl_int m (Z.opp n).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb (Z.ltb n 0) (Z.gtb m 0) then Z.sub (Z.quot (Z.add n 1) m) 1
   else if andb (Z.gtb n 0) (Z.ltb m 0) then Z.sub (Z.quot (Z.sub n 1) m) 1
   else Z.quot n m.

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub n (Z.mul m (fdiv_int n m)).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append str (string_of_bits x).

Definition concat_str_dec (str : string) (x : Z) : string := String.append str (dec_str x).

Definition zero_extend' {n : Z} (m : Z) (v : mword n) (*m >=? n*) : mword m := zero_extend v m.

Definition addition (value : mword 32) : mword 32 := add_vec_int value 57.

Definition reading '(tt : unit) : M (mword 32) :=
   ((read_reg SOME_REG_ref)  : M (mword 32))  : M (mword 32).

Definition combining '(tt : unit) : M (unit) :=
   (reading tt) >>= fun (w__0 : mword 32) => write_reg SOME_REG_ref (addition w__0)  : M (unit).

Definition writing (value : mword 32) : M (unit) := write_reg SOME_REG_ref value  : M (unit).

Definition initial_regstate : regstate :=
{| ANOTHER_REG := (Ox"1234")  : mword 16;
   SOME_REG := (Ox"00000401")  : mword 32 |}.
#[export] Hint Unfold initial_regstate : sail.


